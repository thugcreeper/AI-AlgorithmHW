//NTOU 2025/3/31 N puzzle 
//Full system: an 8-puzzle game
#include <iostream> 
#include <algorithm>
#include <vector>
#include <set>
#include <cmath>
#include <tuple>
#include <string>
using namespace std;

struct dataNode{	
    vector<int> state; 
    int g, h, f; // g: so-far cost; h: estimated cost to goal; f = g + h
    int action,order; 
	dataNode *parent;
    // this state is generated by applying which action to which parent state
};

bool isSolvable(vector<int> puzzle,int len){
	int i,j,count=0,n=sqrt(len);//disorder digits
	for(i=0;i<len;i++){
		for(j=i+1;j<len;j++){
			if(puzzle[i]>puzzle[j] && puzzle[i]>0 && puzzle[j]>0)
				count++;
		}
	}
	/*If n is even, and the index of the row containing the empty tile 
	plus the number of disorder digits is even, the problem is solvable.*/
	if(n%2==0){
		for(i=0;i<len;i++){
			if(puzzle[i]==0){
				count+=i/n;
				break;
			}
		}	
	}
	return count%2==0 ? true : false;
}

int manhattan_distance(vector<int> board,int len){
	int i,n=sqrt(len),distance=0;
	int xi,yi,x,y;

	for(i=0;i<len;i++){
		if(board[i]!=0){
			xi=i%n;//correct position
			yi=i/n;
			x=board[i]%n;//current position
			y=board[i]/n;
			distance+=abs(xi-x)+abs(yi-y);
		}
	}
	return distance;
}

vector<dataNode*> priority_queue;

int insert_order=0;

void enqueue(dataNode* node){
	node->order=insert_order++;
	auto i=priority_queue.begin();//iterator
	while(i<priority_queue.end()){
		if(node->f < (*i)->f){break;}
        //priority queue存放指向dataNode的指標,迭代器i指向一個dataNode*
		//*i就是取該指標 
		if((*i)->order > node->order && (*i)->f == node->f){ //is tied, FIFO
            break;
        }
		i++;
	}
	priority_queue.insert(i,node);//O(n)
}

dataNode* dequeue(){
	if(!priority_queue.empty()){
		//注意front()回傳第一個element 而begin() 回傳第一個iterator 
		dataNode* top=priority_queue.front();
		//erase接 iterator作為參數 
		priority_queue.erase(priority_queue.begin());//O(n)
		return top;
	}
	else{
		cout<<"Queue is empty!!"<<endl;
		return nullptr;
	}
}

tuple <vector<vector<int>>,vector<char>>possibleStep(vector<int> state){
	int x0,y0,i,j;
	int n = sqrt(state.size());
    vector<vector<int>> matrix(n, vector<int>(n));
	vector<vector<int>> nextState;
	vector<char> nextAction;
	vector<int> newState;
    int idx = 0;
    for(i = 0; i < n; ++i){
        for(j = 0; j < n; ++j){
            matrix[i][j] = state[idx++];
            if(matrix[i][j] == 0)	{x0=i;y0=j;}
        }
    }
    
    const int dx[] = {-1, 1, 0, 0};
    const int dy[] = {0, 0, -1, 1};
    const string directions = {'u', 'd', 'l', 'r'};
    
    for (int dir = 0; dir < 4; dir++) {
        int nx = x0 + dx[dir];
        int ny = y0 + dy[dir];
        
        if (nx >= 0 && nx < n && ny >= 0 && ny < n) {
            swap(matrix[x0][y0], matrix[nx][ny]);
            newState.clear();
	        for (auto &row : matrix) newState.insert(newState.end(), row.begin(), row.end());
	        nextState.push_back(newState);
	        nextAction.push_back(directions[dir]);
            swap(matrix[x0][y0], matrix[nx][ny]);
        }
    }
	//printvec(nextState);
	return make_tuple(nextState,nextAction);
}

void freenodes(vector<dataNode*>&nodes){
	for(auto node:nodes){delete node;}
	nodes.clear();//清空vector內所有元素 
}
void printblock(vector<int> board){
	int len=board.size();
	int n=sqrt(len);
	cout<<"_____________"<<endl;
	for(int i=0;i<len;i++){
	    if(i %n== 0){		cout<<"| ";}
		cout<<board[i]<<" | ";
		if(i %n== n-1){		cout<<endl<<"_____________"<<endl;}		
	}
	cout<<endl;
}
void printSolution(dataNode* node) {
    vector<char> actions;
    vector<vector<int>> correctStates;
    while (node && node->parent) {
        actions.push_back(node->action);
        correctStates.push_back(node->state);
        node = node->parent;
    }
    
    // 反轉以獲得正確順序
    reverse(actions.begin(), actions.end());
    reverse(correctStates.begin(),correctStates.end());
    string movement="";
    cout << "Solution path: "<<endl;
    for (int i=0;i<actions.size();i++) {
    	
    	switch(actions[i]) {
			case 'u':
			    movement="up";
			break;
			case 'd':
			    movement="down";
			break;
			case 'l':
				movement="left";
			break;
			case 'r':
				movement="right";
			break;
			default:
			    movement="";
		}
		cout<<"move 0 to "<<movement<<endl;
		printblock(correctStates[i]);
    }
    cout << "\nTotal steps: " << actions.size() << endl;
}

set<vector<int>> visited;//set容器，有元素唯一且排序的特性 

int main(){
	vector<int> const goal ={0,1,2,3,4,5,6,7,8};
	vector<vector<int>> nextState;
	vector<char> nextAction; // for 0 to 4 directions, up, down, left, and right
	string puzzle;
	vector<dataNode*> allNodes; // 儲存所有創建的節點以便清理
	
	cin>>puzzle;
	int len=puzzle.length();
	vector<int> board(len);
	for(int i=0;i<len;i++) board[i]=puzzle[i]-'0';
	cout<<"original state:"<<endl;
	printblock(board);
	
	if(!isSolvable(board,len)){cout<<"No solution!!"<<endl;	return 0;}
	else if(board==goal){cout<<"It is the goal state."<<endl;return 0;}
	//create startNode
	dataNode* startNode = new dataNode() ;
    startNode->state = board;
    startNode->g = 0;
    startNode->h = manhattan_distance(board, len);
    startNode->f = startNode->g + startNode->h;
    startNode->parent = nullptr;
	
	allNodes.push_back(startNode);
	enqueue(startNode);
	dataNode* solutionNode = nullptr;
	
	while(!priority_queue.empty()){
		dataNode* currentNode = dequeue();
		if(currentNode->state==goal){
			solutionNode=currentNode;//solution point to current node
			break;
		}
		visited.insert(currentNode->state);//put the state into visted when it was dequeued
		
		nextState.clear();
        nextAction.clear();
		tie(nextState,nextAction)=possibleStep(currentNode->state);
		for(int i=0;i<nextState.size();i++){
			if (visited.find(nextState[i]) != visited.end()) {//發現到visted state,跳過 
                continue; // 沒找到會回傳.end() 
            }
			dataNode *newnode =new dataNode();
	        newnode->state= nextState[i];
	        newnode->action= nextAction[i];
	        newnode->g = currentNode->g + 1;//g是目前走了幾個node 
	        newnode->h =manhattan_distance(nextState[i],len);
	        newnode->f = newnode->g + newnode->h;
	        newnode->parent = currentNode;
	        
	        allNodes.push_back(newnode);
	        enqueue(newnode);
		}
	}
	if(solutionNode){	printSolution(solutionNode);} 
	else{	cout<<"No solution!!"<<endl;}
	freenodes(allNodes);
	return 0;
}
/*
in:
312457680	
out:
No solution!!
in:
012345678
out:
It is the goal state.
in:
351042678
out:
move 0 to right
move 0 to up
move 0 to right
move 0 to down
move 0 to left
move 0 to left
move 0 to up
*/
